# DataDr Frontend: Architecture & Maintainability Recommendations

## Executive Summary

Your frontend is well-structured for a v1 product. It uses modern tooling (Vite, React Query, shadcn/ui, TypeScript) and has clear feature separation. However, as you add lineage, more adapters, and enterprise features, certain patterns will become pain points.

This document identifies **7 architectural improvements** that will make your codebase more maintainable and extensible.

---

## Current State Analysis

### What's Working Well âœ…

| Aspect | Status | Notes |
|--------|--------|-------|
| **Tech Stack** | âœ… Good | Vite, React 18, TanStack Query, TypeScript, shadcn/ui |
| **Feature Organization** | âœ… Good | `features/` directory with domain separation |
| **API Client** | âœ… Good | Custom fetch wrapper with auth |
| **Component Library** | âœ… Good | shadcn/ui with consistent styling |
| **State Management** | âœ… Good | React Query for server state |

### Areas for Improvement âš ï¸

| Issue | Impact | Severity |
|-------|--------|----------|
| Manual type definitions | Types drift from backend | Medium |
| Inconsistent form handling | Hard to add new forms | Medium |
| No error boundary strategy | Crashes break whole app | High |
| Hardcoded form fields | Can't do dynamic forms | High |
| No loading/error patterns | Duplicated code | Medium |
| Mixed concerns in components | Hard to test | Medium |
| No feature flag system | Can't ship incrementally | Low |

---

## Recommendation 1: Generate API Types from OpenAPI

### Problem

You have `lib/api/types.ts` with manually defined types:

```typescript
// Current: Manual types that drift from backend
export interface CreateInvestigationRequest {
  dataset_id: string
  metric_name: string
  // ... manually kept in sync
}
```

You also have Orval configured but the comment says "would normally be generated."

### Solution

**Actually use Orval to generate types and hooks.** Your `orval.config.ts` is already set up.

```bash
# Generate types from OpenAPI spec
pnpm orval
```

### Benefits

- **Type safety**: Frontend types always match backend
- **Auto-generated hooks**: `useGetInvestigations()`, `useCreateInvestigation()` etc.
- **No manual sync**: Backend changes automatically propagate

### Implementation

```typescript
// Before: Manual hooks
export function useInvestigations() {
  return useQuery({
    queryKey: ['investigations'],
    queryFn: async () => {
      const response = await customInstance<InvestigationListItem[]>({
        url: '/investigations',
        method: 'GET',
      })
      return Array.isArray(response) ? response : []
    },
  })
}

// After: Generated by Orval (you just import)
import { useGetInvestigations } from '@/lib/api/generated/investigations'

function MyComponent() {
  const { data, isLoading } = useGetInvestigations()
}
```

### Action Items

1. Ensure backend exports valid `openapi.json`
2. Run `pnpm orval` to generate
3. Replace manual types/hooks with generated ones
4. Delete `lib/api/types.ts` (use generated model instead)
5. Add `pnpm orval` to CI to catch drift

---

## Recommendation 2: Dynamic Form System

### Problem

`DataSourceForm` has hardcoded fields for PostgreSQL-like databases:

```typescript
// Current: Hardcoded form fields
const DATA_SOURCE_TYPES = [
  { value: 'postgres', label: 'PostgreSQL', defaultPort: '5432' },
  { value: 'trino', label: 'Trino', defaultPort: '8080' },
  // ...
]

// Same fields for every type
<Input id="host" ... />
<Input id="port" ... />
<Input id="database" ... />
```

This breaks when adding:
- MongoDB (connection string, not host/port)
- Salesforce (OAuth, not username/password)
- S3 (bucket, region, access key)

### Solution

**Schema-driven dynamic forms.** Backend returns field schema, frontend renders dynamically.

```typescript
// Backend returns config schema per source type
interface FieldDefinition {
  name: string
  label: string
  type: 'string' | 'integer' | 'secret' | 'enum' | 'boolean'
  required: boolean
  placeholder?: string
  default?: unknown
  options?: { value: string; label: string }[]  // For enums
  showIf?: { field: string; value: unknown }    // Conditional
  group?: string                                 // Field grouping
}

interface SourceTypeSchema {
  type: string
  displayName: string
  icon: string
  fields: FieldDefinition[]
  fieldGroups?: { id: string; label: string }[]
}
```

### New Component: `DynamicForm`

```typescript
// components/forms/dynamic-form.tsx

interface DynamicFormProps {
  schema: FieldDefinition[]
  values: Record<string, unknown>
  onChange: (values: Record<string, unknown>) => void
  errors?: Record<string, string>
}

export function DynamicForm({ schema, values, onChange, errors }: DynamicFormProps) {
  return (
    <div className="space-y-4">
      {schema.map((field) => {
        // Check conditional visibility
        if (field.showIf) {
          const { field: dependsOn, value: expectedValue } = field.showIf
          if (values[dependsOn] !== expectedValue) return null
        }

        return (
          <DynamicField
            key={field.name}
            field={field}
            value={values[field.name]}
            onChange={(v) => onChange({ ...values, [field.name]: v })}
            error={errors?.[field.name]}
          />
        )
      })}
    </div>
  )
}

function DynamicField({ field, value, onChange, error }: {
  field: FieldDefinition
  value: unknown
  onChange: (value: unknown) => void
  error?: string
}) {
  switch (field.type) {
    case 'string':
      return (
        <div className="grid gap-2">
          <Label htmlFor={field.name}>{field.label}</Label>
          <Input
            id={field.name}
            value={(value as string) ?? ''}
            onChange={(e) => onChange(e.target.value)}
            placeholder={field.placeholder}
            required={field.required}
          />
          {error && <p className="text-sm text-destructive">{error}</p>}
        </div>
      )

    case 'secret':
      return (
        <div className="grid gap-2">
          <Label htmlFor={field.name}>{field.label}</Label>
          <Input
            id={field.name}
            type="password"
            value={(value as string) ?? ''}
            onChange={(e) => onChange(e.target.value)}
            placeholder={field.placeholder}
            required={field.required}
          />
        </div>
      )

    case 'enum':
      return (
        <div className="grid gap-2">
          <Label htmlFor={field.name}>{field.label}</Label>
          <Select value={value as string} onValueChange={onChange}>
            <SelectTrigger>
              <SelectValue placeholder={field.placeholder ?? 'Select...'} />
            </SelectTrigger>
            <SelectContent>
              {field.options?.map((opt) => (
                <SelectItem key={opt.value} value={opt.value}>
                  {opt.label}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>
      )

    case 'boolean':
      return (
        <div className="flex items-center gap-2">
          <Checkbox
            id={field.name}
            checked={value as boolean}
            onCheckedChange={onChange}
          />
          <Label htmlFor={field.name}>{field.label}</Label>
        </div>
      )

    case 'integer':
      return (
        <div className="grid gap-2">
          <Label htmlFor={field.name}>{field.label}</Label>
          <Input
            id={field.name}
            type="number"
            value={(value as number)?.toString() ?? ''}
            onChange={(e) => onChange(parseInt(e.target.value) || undefined)}
            placeholder={field.placeholder}
            required={field.required}
          />
        </div>
      )

    default:
      return null
  }
}
```

### Updated DataSourceForm

```typescript
// features/datasources/datasource-form.tsx

export function DataSourceForm({ open, onOpenChange }: DataSourceFormProps) {
  const [selectedType, setSelectedType] = useState<string | null>(null)
  const [formValues, setFormValues] = useState<Record<string, unknown>>({})

  // Fetch available source types with their schemas
  const { data: sourceTypes } = useSourceTypes()

  const selectedSchema = sourceTypes?.find(t => t.type === selectedType)

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Add Data Source</DialogTitle>
        </DialogHeader>

        {/* Step 1: Select type */}
        {!selectedType ? (
          <SourceTypeSelector
            types={sourceTypes ?? []}
            onSelect={setSelectedType}
          />
        ) : (
          /* Step 2: Dynamic form based on type */
          <>
            <Button variant="ghost" onClick={() => setSelectedType(null)}>
              â† Change type
            </Button>

            <DynamicForm
              schema={selectedSchema?.fields ?? []}
              values={formValues}
              onChange={setFormValues}
            />

            <DialogFooter>
              <Button onClick={handleTest}>Test Connection</Button>
              <Button onClick={handleSubmit}>Create</Button>
            </DialogFooter>
          </>
        )}
      </DialogContent>
    </Dialog>
  )
}
```

### Benefits

- **Add source types without frontend changes**
- **Backend owns field definitions** (single source of truth)
- **Conditional fields** (show OAuth fields only when auth_type=oauth)
- **Reusable** for lineage providers, LLM providers, notifications

---

## Recommendation 3: Standardized Async State Handling

### Problem

Every page has duplicated loading/error handling:

```typescript
// Repeated in every page:
if (isLoading) {
  return (
    <div className="flex items-center justify-center py-12">
      <RefreshCw className="h-8 w-8 animate-spin text-muted-foreground" />
    </div>
  )
}

if (error) {
  return (
    <Card>
      <CardContent className="py-12 text-center">
        <p className="text-destructive">Failed to load: {error.message}</p>
        <Button onClick={() => refetch()}>Retry</Button>
      </CardContent>
    </Card>
  )
}
```

### Solution

**Create `AsyncBoundary` component** that handles loading, error, and empty states.

```typescript
// components/async-boundary.tsx

interface AsyncBoundaryProps<T> {
  query: UseQueryResult<T>
  loadingFallback?: React.ReactNode
  errorFallback?: (error: Error, retry: () => void) => React.ReactNode
  emptyFallback?: React.ReactNode
  isEmpty?: (data: T) => boolean
  children: (data: T) => React.ReactNode
}

export function AsyncBoundary<T>({
  query,
  loadingFallback,
  errorFallback,
  emptyFallback,
  isEmpty,
  children,
}: AsyncBoundaryProps<T>) {
  const { data, isLoading, error, refetch } = query

  if (isLoading) {
    return loadingFallback ?? <DefaultLoadingState />
  }

  if (error) {
    return errorFallback?.(error, refetch) ?? (
      <DefaultErrorState error={error} onRetry={refetch} />
    )
  }

  if (data && isEmpty?.(data)) {
    return emptyFallback ?? null
  }

  if (!data) {
    return null
  }

  return <>{children(data)}</>
}

function DefaultLoadingState() {
  return (
    <div className="flex items-center justify-center py-12">
      <LoadingSpinner size="lg" />
    </div>
  )
}

function DefaultErrorState({ error, onRetry }: { error: Error; onRetry: () => void }) {
  return (
    <div className="flex flex-col items-center justify-center py-12 space-y-4">
      <div className="flex items-center gap-3 rounded-lg border border-destructive/50 bg-destructive/10 p-4">
        <AlertCircle className="h-5 w-5 text-destructive" />
        <div>
          <p className="font-medium text-destructive">Something went wrong</p>
          <p className="text-sm text-muted-foreground">{error.message}</p>
        </div>
      </div>
      <Button variant="outline" onClick={onRetry}>
        <RefreshCw className="mr-2 h-4 w-4" />
        Try again
      </Button>
    </div>
  )
}
```

### Usage

```typescript
// Before: 30+ lines of loading/error handling
export function InvestigationList() {
  const query = useInvestigations()

  if (query.isLoading) { /* ... */ }
  if (query.error) { /* ... */ }

  return <div>{query.data?.map(...)}</div>
}

// After: Clean and declarative
export function InvestigationList() {
  const query = useInvestigations()

  return (
    <AsyncBoundary
      query={query}
      isEmpty={(data) => data.length === 0}
      emptyFallback={
        <EmptyState
          icon={Search}
          title="No investigations"
          description="Start by creating your first investigation"
          action={<Button asChild><Link to="/investigations/new">Create</Link></Button>}
        />
      }
    >
      {(investigations) => (
        <div className="space-y-4">
          {investigations.map((inv) => (
            <InvestigationCard key={inv.id} investigation={inv} />
          ))}
        </div>
      )}
    </AsyncBoundary>
  )
}
```

---

## Recommendation 4: Error Boundaries

### Problem

No React error boundaries. If a component crashes, the whole app crashes.

### Solution

**Add error boundaries at feature level.**

```typescript
// components/error-boundary.tsx

import { Component, ErrorInfo, ReactNode } from 'react'

interface Props {
  children: ReactNode
  fallback?: ReactNode
  onError?: (error: Error, errorInfo: ErrorInfo) => void
}

interface State {
  hasError: boolean
  error: Error | null
}

export class ErrorBoundary extends Component<Props, State> {
  state: State = { hasError: false, error: null }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error }
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Error boundary caught:', error, errorInfo)
    this.props.onError?.(error, errorInfo)
    // Could send to error tracking service
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback ?? (
        <div className="flex flex-col items-center justify-center py-12">
          <AlertTriangle className="h-12 w-12 text-destructive mb-4" />
          <h2 className="text-lg font-semibold">Something went wrong</h2>
          <p className="text-muted-foreground mb-4">
            {this.state.error?.message ?? 'An unexpected error occurred'}
          </p>
          <Button onClick={() => this.setState({ hasError: false, error: null })}>
            Try again
          </Button>
        </div>
      )
    }

    return this.props.children
  }
}
```

### Apply at Route Level

```typescript
// App.tsx

function App() {
  return (
    <AuthProvider>
      <Routes>
        <Route path="/login" element={<LoginPage />} />
        <Route
          path="/*"
          element={
            <RequireAuth>
              <AppLayout>
                <ErrorBoundary>
                  <Routes>
                    <Route index element={<DashboardPage />} />
                    <Route path="investigations/*" element={
                      <ErrorBoundary>
                        <Routes>
                          <Route index element={<InvestigationList />} />
                          <Route path="new" element={<NewInvestigation />} />
                          <Route path=":id" element={<InvestigationDetail />} />
                        </Routes>
                      </ErrorBoundary>
                    } />
                    {/* ... */}
                  </Routes>
                </ErrorBoundary>
              </AppLayout>
            </RequireAuth>
          }
        />
      </Routes>
    </AuthProvider>
  )
}
```

---

## Recommendation 5: Centralized Query Keys

### Problem

Query keys are scattered across files as magic strings:

```typescript
// In investigations.ts
const INVESTIGATIONS_KEY = 'investigations'
queryKey: [INVESTIGATIONS_KEY, id]

// In datasources.ts
const DATASOURCES_KEY = 'datasources'
queryKey: ['datasource-schema', datasourceId]
queryKey: ['table-search', datasourceId, searchTerm]
```

This makes it hard to:
- Invalidate related queries
- Debug cache issues
- Prevent key collisions

### Solution

**Centralized query key factory.**

```typescript
// lib/api/query-keys.ts

export const queryKeys = {
  // Investigations
  investigations: {
    all: ['investigations'] as const,
    lists: () => [...queryKeys.investigations.all, 'list'] as const,
    list: (filters: Record<string, unknown>) =>
      [...queryKeys.investigations.lists(), filters] as const,
    details: () => [...queryKeys.investigations.all, 'detail'] as const,
    detail: (id: string) => [...queryKeys.investigations.details(), id] as const,
  },

  // Data Sources
  datasources: {
    all: ['datasources'] as const,
    lists: () => [...queryKeys.datasources.all, 'list'] as const,
    list: (filters?: { type?: string }) =>
      [...queryKeys.datasources.lists(), filters] as const,
    details: () => [...queryKeys.datasources.all, 'detail'] as const,
    detail: (id: string) => [...queryKeys.datasources.details(), id] as const,
    schema: (id: string) => [...queryKeys.datasources.detail(id), 'schema'] as const,
    tables: (id: string, search?: string) =>
      [...queryKeys.datasources.detail(id), 'tables', search] as const,
  },

  // Lineage (future)
  lineage: {
    all: ['lineage'] as const,
    graph: (platform: string, dataset: string, depth: number) =>
      [...queryKeys.lineage.all, 'graph', platform, dataset, depth] as const,
    upstream: (platform: string, dataset: string) =>
      [...queryKeys.lineage.all, 'upstream', platform, dataset] as const,
    downstream: (platform: string, dataset: string) =>
      [...queryKeys.lineage.all, 'downstream', platform, dataset] as const,
  },

  // Dashboard
  dashboard: {
    stats: ['dashboard', 'stats'] as const,
  },

  // Source Types (reference data)
  sourceTypes: ['source-types'] as const,
} as const
```

### Usage

```typescript
// Before
useQuery({
  queryKey: ['datasource-schema', datasourceId],
  queryFn: ...
})

// After
import { queryKeys } from '@/lib/api/query-keys'

useQuery({
  queryKey: queryKeys.datasources.schema(datasourceId),
  queryFn: ...
})

// Invalidation becomes clearer
queryClient.invalidateQueries({
  queryKey: queryKeys.datasources.all  // Invalidates all datasource queries
})

queryClient.invalidateQueries({
  queryKey: queryKeys.datasources.detail(id)  // Invalidates just this datasource
})
```

---

## Recommendation 6: Extract Business Logic from Components

### Problem

Components mix UI and business logic. Example from `NewInvestigation.tsx`:

```typescript
// 700+ line component with:
// - Form state management
// - Mock lineage generation
// - Table search/selection
// - Schema viewing
// - Multiple sub-components defined inline
```

This makes it hard to:
- Test business logic
- Reuse logic across components
- Understand what the component does

### Solution

**Extract custom hooks for business logic.**

```typescript
// hooks/use-investigation-form.ts

interface UseInvestigationFormOptions {
  onSuccess?: (investigation: InvestigationResponse) => void
}

interface DatasetEntry {
  id: string
  datasourceId: string
  identifier: string
  table: SchemaTable | null
}

export function useInvestigationForm(options?: UseInvestigationFormOptions) {
  const navigate = useNavigate()
  const createMutation = useCreateInvestigation()

  const [datasets, setDatasets] = useState<DatasetEntry[]>([
    { id: '1', datasourceId: '', identifier: '', table: null }
  ])
  const [anomalyDate, setAnomalyDate] = useState<DatePickerValue | undefined>()
  const [description, setDescription] = useState('')

  const addDataset = useCallback(() => {
    setDatasets(prev => [
      ...prev,
      { id: crypto.randomUUID(), datasourceId: prev[0]?.datasourceId ?? '', identifier: '', table: null }
    ])
  }, [])

  const removeDataset = useCallback((id: string) => {
    setDatasets(prev => prev.filter(d => d.id !== id))
  }, [])

  const updateDataset = useCallback((id: string, updates: Partial<DatasetEntry>) => {
    setDatasets(prev => prev.map(d => d.id === id ? { ...d, ...updates } : d))
  }, [])

  const canSubmit = useMemo(() => {
    const hasValidDataset = datasets.some(d => d.datasourceId && d.identifier)
    return hasValidDataset && !createMutation.isPending
  }, [datasets, createMutation.isPending])

  const submit = useCallback(async () => {
    const primaryDataset = datasets.find(d => d.datasourceId && d.identifier)
    if (!primaryDataset) return

    const result = await createMutation.mutateAsync({
      dataset_id: primaryDataset.identifier,
      // ... other fields
    })

    options?.onSuccess?.(result)
    navigate(`/investigations/${result.investigation_id}`)
  }, [datasets, createMutation, navigate, options])

  return {
    // State
    datasets,
    anomalyDate,
    description,
    canSubmit,
    isSubmitting: createMutation.isPending,
    error: createMutation.error,

    // Actions
    addDataset,
    removeDataset,
    updateDataset,
    setAnomalyDate,
    setDescription,
    submit,
  }
}
```

### Cleaner Component

```typescript
// features/investigation/new-investigation.tsx

export function NewInvestigation() {
  const { data: dataSources } = useDataSources()
  const form = useInvestigationForm()

  return (
    <div className="space-y-6">
      <PageHeader title="New Investigation" />

      <Card>
        <CardContent className="pt-6">
          {form.datasets.map((dataset, index) => (
            <DatasetEntry
              key={dataset.id}
              {...dataset}
              dataSources={dataSources ?? []}
              onDatasourceChange={(id) => form.updateDataset(dataset.id, { datasourceId: id })}
              onIdentifierChange={(id) => form.updateDataset(dataset.id, { identifier: id })}
              onTableSelect={(table) => form.updateDataset(dataset.id, { table })}
              onRemove={() => form.removeDataset(dataset.id)}
              canRemove={form.datasets.length > 1}
              autoFocus={index === form.datasets.length - 1}
            />
          ))}

          <Button variant="outline" onClick={form.addDataset}>
            <Plus className="mr-2 h-4 w-4" /> Add Dataset
          </Button>
        </CardContent>
      </Card>

      <Button onClick={form.submit} disabled={!form.canSubmit}>
        {form.isSubmitting ? 'Starting...' : 'Start Investigation'}
      </Button>
    </div>
  )
}
```

---

## Recommendation 7: Feature Flags (Optional)

### Problem

No way to ship features incrementally or enable features for specific tenants.

### Solution

**Simple feature flag system.**

```typescript
// lib/feature-flags.ts

type FeatureFlag =
  | 'lineage'
  | 'column-lineage'
  | 'llm-provider-selection'
  | 'notifications'
  | 'advanced-settings'

// Could come from backend, localStorage, or LaunchDarkly
const defaultFlags: Record<FeatureFlag, boolean> = {
  'lineage': false,
  'column-lineage': false,
  'llm-provider-selection': false,
  'notifications': true,
  'advanced-settings': false,
}

export function useFeatureFlag(flag: FeatureFlag): boolean {
  // In real implementation, fetch from backend or feature flag service
  const { data: tenant } = useTenant()

  // Check tenant-specific overrides
  if (tenant?.featureFlags?.[flag] !== undefined) {
    return tenant.featureFlags[flag]
  }

  // Fall back to defaults
  return defaultFlags[flag]
}
```

### Usage

```typescript
// In sidebar
function AppSidebar() {
  const showLineage = useFeatureFlag('lineage')

  return (
    <Sidebar>
      {/* ... */}
      {showLineage && (
        <SidebarMenuItem>
          <Link to="/lineage">
            <GitBranch className="size-4" />
            <span>Lineage</span>
          </Link>
        </SidebarMenuItem>
      )}
    </Sidebar>
  )
}
```

---

## Updated Directory Structure

After implementing these recommendations:

```
frontend/src/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ ui/                          # shadcn components (unchanged)
â”‚   â”œâ”€â”€ shared/
â”‚   â”‚   â”œâ”€â”€ page-header.tsx
â”‚   â”‚   â”œâ”€â”€ empty-state.tsx
â”‚   â”‚   â”œâ”€â”€ loading-spinner.tsx
â”‚   â”‚   â””â”€â”€ platform-icon.tsx        # NEW
â”‚   â”œâ”€â”€ forms/
â”‚   â”‚   â”œâ”€â”€ dynamic-form.tsx         # NEW: Schema-driven forms
â”‚   â”‚   â”œâ”€â”€ dynamic-field.tsx        # NEW
â”‚   â”‚   â””â”€â”€ field-group.tsx          # NEW
â”‚   â”œâ”€â”€ async-boundary.tsx           # NEW: Loading/error handling
â”‚   â”œâ”€â”€ error-boundary.tsx           # NEW: Crash recovery
â”‚   â””â”€â”€ layout/
â”‚       â””â”€â”€ app-sidebar.tsx
â”‚
â”œâ”€â”€ features/
â”‚   â”œâ”€â”€ dashboard/
â”‚   â”œâ”€â”€ investigation/
â”‚   â”‚   â”œâ”€â”€ components/              # NEW: Extract sub-components
â”‚   â”‚   â”‚   â”œâ”€â”€ dataset-entry.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ schema-viewer.tsx
â”‚   â”‚   â”‚   â””â”€â”€ lineage-panel.tsx
â”‚   â”‚   â”œâ”€â”€ hooks/                   # NEW: Extract business logic
â”‚   â”‚   â”‚   â””â”€â”€ use-investigation-form.ts
â”‚   â”‚   â”œâ”€â”€ investigation-list.tsx
â”‚   â”‚   â”œâ”€â”€ investigation-detail.tsx
â”‚   â”‚   â””â”€â”€ new-investigation.tsx
â”‚   â”œâ”€â”€ datasources/
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â””â”€â”€ source-type-selector.tsx  # NEW
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ lineage/                     # NEW: Lineage feature
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â””â”€â”€ lineage-explorer.tsx
â”‚   â””â”€â”€ settings/
â”‚
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ use-mobile.tsx
â”‚   â””â”€â”€ use-debounce.ts              # NEW: Common utility hooks
â”‚
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”œâ”€â”€ client.ts
â”‚   â”‚   â”œâ”€â”€ query-keys.ts            # NEW: Centralized keys
â”‚   â”‚   â”œâ”€â”€ generated/               # NEW: Orval-generated
â”‚   â”‚   â”‚   â”œâ”€â”€ investigations.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ datasources.ts
â”‚   â”‚   â”‚   â””â”€â”€ model/
â”‚   â”‚   â””â”€â”€ [remove manual files]
â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â””â”€â”€ context.tsx
â”‚   â”œâ”€â”€ feature-flags.ts             # NEW
â”‚   â””â”€â”€ utils.ts
â”‚
â””â”€â”€ App.tsx                          # Add error boundaries
```

---

## Implementation Priority

| Recommendation | Effort | Impact | Priority |
|----------------|--------|--------|----------|
| 1. Generate API types | Low | High | ğŸ”´ Do now |
| 3. AsyncBoundary | Low | Medium | ğŸ”´ Do now |
| 4. Error Boundaries | Low | High | ğŸ”´ Do now |
| 5. Query key factory | Low | Medium | ğŸŸ¡ Soon |
| 6. Extract hooks | Medium | High | ğŸŸ¡ Soon |
| 2. Dynamic forms | Medium | High | ğŸŸ¡ Before adding adapters |
| 7. Feature flags | Low | Low | ğŸŸ¢ When needed |

### Quick Wins (This Week)

1. Run `pnpm orval` and use generated types
2. Create `AsyncBoundary` component
3. Add `ErrorBoundary` at route level
4. Create `queryKeys` factory

### Before Adding Lineage

1. Implement `DynamicForm` component
2. Extract `useInvestigationForm` hook
3. Clean up `NewInvestigation.tsx`

---

## Summary

Your frontend is in good shape for a v1. The main improvements are:

1. **Stop manually syncing types** â†’ Use Orval
2. **Stop hardcoding forms** â†’ Schema-driven dynamic forms
3. **Stop duplicating loading/error handling** â†’ AsyncBoundary
4. **Stop risking full-app crashes** â†’ Error boundaries
5. **Stop scattering query keys** â†’ Centralized factory
6. **Stop mixing concerns** â†’ Extract custom hooks

These changes will make adding lineage, new adapters, and enterprise features much smoother.
