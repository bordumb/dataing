"""Structured response models for LLM outputs.

These models define the exact schema expected from the LLM.
Pydantic AI uses these for:
1. Generating schema hints in the prompt
2. Validating LLM responses
3. Automatic retry on validation failure
"""

from __future__ import annotations

from pydantic import BaseModel, Field, field_validator

from dataing.core.domain_types import HypothesisCategory


class HypothesisResponse(BaseModel):
    """Single hypothesis from the LLM."""

    id: str = Field(description="Unique identifier like 'h1', 'h2', etc.")
    title: str = Field(
        description="Short, specific title describing the potential cause",
        min_length=10,
        max_length=200,
    )
    category: HypothesisCategory = Field(description="Classification of the hypothesis type")
    reasoning: str = Field(
        description="Explanation of why this could be the cause",
        min_length=20,
    )
    suggested_query: str = Field(
        description="SQL query to investigate this hypothesis. Must include LIMIT clause.",
    )

    @field_validator("suggested_query")
    @classmethod
    def validate_query_has_limit(cls, v: str) -> str:
        """Ensure query has LIMIT clause for safety."""
        if "LIMIT" not in v.upper():
            raise ValueError("Query must include LIMIT clause")
        return v

    @field_validator("suggested_query")
    @classmethod
    def validate_no_mutations(cls, v: str) -> str:
        """Ensure query is read-only."""
        dangerous = ["INSERT", "UPDATE", "DELETE", "DROP", "TRUNCATE", "ALTER"]
        upper_query = v.upper()
        for keyword in dangerous:
            if keyword in upper_query:
                raise ValueError(f"Query contains forbidden keyword: {keyword}")
        return v


class HypothesesResponse(BaseModel):
    """Container for multiple hypotheses."""

    hypotheses: list[HypothesisResponse] = Field(
        description="List of hypotheses to investigate",
        min_length=1,
        max_length=10,
    )


class QueryResponse(BaseModel):
    """SQL query generated by LLM."""

    query: str = Field(description="The SQL query to execute")
    explanation: str = Field(
        description="Brief explanation of what the query tests",
        default="",
    )

    @field_validator("query")
    @classmethod
    def validate_query(cls, v: str) -> str:
        """Validate the generated SQL."""
        # Strip markdown if present
        if v.startswith("```"):
            lines = v.strip().split("\n")
            v = "\n".join(lines[1:-1] if lines[-1] == "```" else lines[1:])

        upper_query = v.upper().strip()

        if not upper_query.startswith("SELECT"):
            raise ValueError("Query must be a SELECT statement")

        if "LIMIT" not in upper_query:
            raise ValueError("Query must include LIMIT clause")

        return v.strip()


class InterpretationResponse(BaseModel):
    """LLM interpretation of query results."""

    supports_hypothesis: bool | None = Field(
        description="True if evidence supports, False if refutes, None if inconclusive"
    )
    confidence: float = Field(
        ge=0.0,
        le=1.0,
        description="Confidence score from 0.0 (no confidence) to 1.0 (certain)",
    )
    interpretation: str = Field(
        description="Human-readable explanation of what the results show",
        min_length=20,
    )
    key_findings: list[str] = Field(
        default_factory=list,
        description="Bullet points of the most important findings",
        max_length=5,
    )


class SynthesisResponse(BaseModel):
    """Final synthesis of all evidence into a finding."""

    root_cause: str | None = Field(
        description="Concise description of the root cause, or null if inconclusive"
    )
    confidence: float = Field(
        ge=0.0,
        le=1.0,
        description="Confidence in the root cause determination",
    )
    supporting_evidence: list[str] = Field(
        description="Key evidence points that support this conclusion",
        max_length=10,
    )
    recommendations: list[str] = Field(
        description="Actionable recommendations to fix or prevent the issue",
        min_length=1,
        max_length=5,
    )

    @field_validator("root_cause")
    @classmethod
    def validate_root_cause_quality(cls, v: str | None) -> str | None:
        """Ensure root cause is specific enough."""
        if v is not None and len(v) < 20:
            raise ValueError("Root cause description too vague (min 20 chars)")
        return v
