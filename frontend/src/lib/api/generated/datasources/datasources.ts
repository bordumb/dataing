/**
 * Generated by orval v6.31.0 ðŸº
 * Do not edit manually.
 * dataing
 * Autonomous Data Quality Investigation
 * OpenAPI spec version: 2.0.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";
import type {
  CreateDataSourceRequest,
  DataSourceListResponse,
  DataSourceResponse,
  DatasourceDatasetsResponse,
  GetDatasourceSchemaApiV1DatasourcesDatasourceIdSchemaGetParams,
  GetDatasourceSchemaApiV1V2DatasourcesDatasourceIdSchemaGetParams,
  HTTPValidationError,
  ListDatasourceDatasetsApiV1DatasourcesDatasourceIdDatasetsGetParams,
  ListDatasourceDatasetsApiV1V2DatasourcesDatasourceIdDatasetsGetParams,
  QueryRequest,
  QueryResponse,
  SchemaResponseModel,
  SourceTypesResponse,
  StatsRequest,
  StatsResponse,
  SyncResponse,
  TestConnectionRequest,
  TestConnectionResponse,
} from "../../model";
import { customInstance } from "../../client";

/**
 * List all supported data source types.

Returns the configuration schema for each type, which can be used
to dynamically generate connection forms in the frontend.
 * @summary List Source Types
 */
export const listSourceTypesApiV1DatasourcesTypesGet = (
  signal?: AbortSignal,
) => {
  return customInstance<SourceTypesResponse>({
    url: `/api/v1/datasources/types`,
    method: "GET",
    signal,
  });
};

export const getListSourceTypesApiV1DatasourcesTypesGetQueryKey = () => {
  return [`/api/v1/datasources/types`] as const;
};

export const getListSourceTypesApiV1DatasourcesTypesGetQueryOptions = <
  TData = Awaited<ReturnType<typeof listSourceTypesApiV1DatasourcesTypesGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof listSourceTypesApiV1DatasourcesTypesGet>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getListSourceTypesApiV1DatasourcesTypesGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listSourceTypesApiV1DatasourcesTypesGet>>
  > = ({ signal }) => listSourceTypesApiV1DatasourcesTypesGet(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listSourceTypesApiV1DatasourcesTypesGet>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ListSourceTypesApiV1DatasourcesTypesGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof listSourceTypesApiV1DatasourcesTypesGet>>
>;
export type ListSourceTypesApiV1DatasourcesTypesGetQueryError = unknown;

/**
 * @summary List Source Types
 */
export const useListSourceTypesApiV1DatasourcesTypesGet = <
  TData = Awaited<ReturnType<typeof listSourceTypesApiV1DatasourcesTypesGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof listSourceTypesApiV1DatasourcesTypesGet>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions =
    getListSourceTypesApiV1DatasourcesTypesGetQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Test a connection without saving it.

Use this endpoint to validate connection settings before creating
a data source.
 * @summary Test Connection
 */
export const testConnectionApiV1DatasourcesTestPost = (
  testConnectionRequest: TestConnectionRequest,
) => {
  return customInstance<TestConnectionResponse>({
    url: `/api/v1/datasources/test`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: testConnectionRequest,
  });
};

export const getTestConnectionApiV1DatasourcesTestPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof testConnectionApiV1DatasourcesTestPost>>,
    TError,
    { data: TestConnectionRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof testConnectionApiV1DatasourcesTestPost>>,
  TError,
  { data: TestConnectionRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof testConnectionApiV1DatasourcesTestPost>>,
    { data: TestConnectionRequest }
  > = (props) => {
    const { data } = props ?? {};

    return testConnectionApiV1DatasourcesTestPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type TestConnectionApiV1DatasourcesTestPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof testConnectionApiV1DatasourcesTestPost>>
>;
export type TestConnectionApiV1DatasourcesTestPostMutationBody =
  TestConnectionRequest;
export type TestConnectionApiV1DatasourcesTestPostMutationError =
  HTTPValidationError;

/**
 * @summary Test Connection
 */
export const useTestConnectionApiV1DatasourcesTestPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof testConnectionApiV1DatasourcesTestPost>>,
    TError,
    { data: TestConnectionRequest },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof testConnectionApiV1DatasourcesTestPost>>,
  TError,
  { data: TestConnectionRequest },
  TContext
> => {
  const mutationOptions =
    getTestConnectionApiV1DatasourcesTestPostMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * List all data sources for the current tenant.
 * @summary List Datasources
 */
export const listDatasourcesApiV1DatasourcesGet = (signal?: AbortSignal) => {
  return customInstance<DataSourceListResponse>({
    url: `/api/v1/datasources/`,
    method: "GET",
    signal,
  });
};

export const getListDatasourcesApiV1DatasourcesGetQueryKey = () => {
  return [`/api/v1/datasources/`] as const;
};

export const getListDatasourcesApiV1DatasourcesGetQueryOptions = <
  TData = Awaited<ReturnType<typeof listDatasourcesApiV1DatasourcesGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof listDatasourcesApiV1DatasourcesGet>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getListDatasourcesApiV1DatasourcesGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listDatasourcesApiV1DatasourcesGet>>
  > = ({ signal }) => listDatasourcesApiV1DatasourcesGet(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listDatasourcesApiV1DatasourcesGet>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ListDatasourcesApiV1DatasourcesGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof listDatasourcesApiV1DatasourcesGet>>
>;
export type ListDatasourcesApiV1DatasourcesGetQueryError = unknown;

/**
 * @summary List Datasources
 */
export const useListDatasourcesApiV1DatasourcesGet = <
  TData = Awaited<ReturnType<typeof listDatasourcesApiV1DatasourcesGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof listDatasourcesApiV1DatasourcesGet>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions =
    getListDatasourcesApiV1DatasourcesGetQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create a new data source.

Tests the connection before saving. Returns 400 if connection test fails.
 * @summary Create Datasource
 */
export const createDatasourceApiV1DatasourcesPost = (
  createDataSourceRequest: CreateDataSourceRequest,
) => {
  return customInstance<DataSourceResponse>({
    url: `/api/v1/datasources/`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: createDataSourceRequest,
  });
};

export const getCreateDatasourceApiV1DatasourcesPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createDatasourceApiV1DatasourcesPost>>,
    TError,
    { data: CreateDataSourceRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createDatasourceApiV1DatasourcesPost>>,
  TError,
  { data: CreateDataSourceRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createDatasourceApiV1DatasourcesPost>>,
    { data: CreateDataSourceRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createDatasourceApiV1DatasourcesPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateDatasourceApiV1DatasourcesPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createDatasourceApiV1DatasourcesPost>>
>;
export type CreateDatasourceApiV1DatasourcesPostMutationBody =
  CreateDataSourceRequest;
export type CreateDatasourceApiV1DatasourcesPostMutationError =
  HTTPValidationError;

/**
 * @summary Create Datasource
 */
export const useCreateDatasourceApiV1DatasourcesPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createDatasourceApiV1DatasourcesPost>>,
    TError,
    { data: CreateDataSourceRequest },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof createDatasourceApiV1DatasourcesPost>>,
  TError,
  { data: CreateDataSourceRequest },
  TContext
> => {
  const mutationOptions =
    getCreateDatasourceApiV1DatasourcesPostMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Get a specific data source.
 * @summary Get Datasource
 */
export const getDatasourceApiV1DatasourcesDatasourceIdGet = (
  datasourceId: string,
  signal?: AbortSignal,
) => {
  return customInstance<DataSourceResponse>({
    url: `/api/v1/datasources/${datasourceId}`,
    method: "GET",
    signal,
  });
};

export const getGetDatasourceApiV1DatasourcesDatasourceIdGetQueryKey = (
  datasourceId: string,
) => {
  return [`/api/v1/datasources/${datasourceId}`] as const;
};

export const getGetDatasourceApiV1DatasourcesDatasourceIdGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getDatasourceApiV1DatasourcesDatasourceIdGet>
  >,
  TError = HTTPValidationError,
>(
  datasourceId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getDatasourceApiV1DatasourcesDatasourceIdGet>
        >,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetDatasourceApiV1DatasourcesDatasourceIdGetQueryKey(datasourceId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDatasourceApiV1DatasourcesDatasourceIdGet>>
  > = ({ signal }) =>
    getDatasourceApiV1DatasourcesDatasourceIdGet(datasourceId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!datasourceId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getDatasourceApiV1DatasourcesDatasourceIdGet>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetDatasourceApiV1DatasourcesDatasourceIdGetQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof getDatasourceApiV1DatasourcesDatasourceIdGet>>
  >;
export type GetDatasourceApiV1DatasourcesDatasourceIdGetQueryError =
  HTTPValidationError;

/**
 * @summary Get Datasource
 */
export const useGetDatasourceApiV1DatasourcesDatasourceIdGet = <
  TData = Awaited<
    ReturnType<typeof getDatasourceApiV1DatasourcesDatasourceIdGet>
  >,
  TError = HTTPValidationError,
>(
  datasourceId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getDatasourceApiV1DatasourcesDatasourceIdGet>
        >,
        TError,
        TData
      >
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions =
    getGetDatasourceApiV1DatasourcesDatasourceIdGetQueryOptions(
      datasourceId,
      options,
    );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Delete a data source (soft delete).
 * @summary Delete Datasource
 */
export const deleteDatasourceApiV1DatasourcesDatasourceIdDelete = (
  datasourceId: string,
) => {
  return customInstance<void>({
    url: `/api/v1/datasources/${datasourceId}`,
    method: "DELETE",
  });
};

export const getDeleteDatasourceApiV1DatasourcesDatasourceIdDeleteMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof deleteDatasourceApiV1DatasourcesDatasourceIdDelete>
      >,
      TError,
      { datasourceId: string },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof deleteDatasourceApiV1DatasourcesDatasourceIdDelete>
    >,
    TError,
    { datasourceId: string },
    TContext
  > => {
    const { mutation: mutationOptions } = options ?? {};

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof deleteDatasourceApiV1DatasourcesDatasourceIdDelete>
      >,
      { datasourceId: string }
    > = (props) => {
      const { datasourceId } = props ?? {};

      return deleteDatasourceApiV1DatasourcesDatasourceIdDelete(datasourceId);
    };

    return { mutationFn, ...mutationOptions };
  };

export type DeleteDatasourceApiV1DatasourcesDatasourceIdDeleteMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof deleteDatasourceApiV1DatasourcesDatasourceIdDelete>
    >
  >;

export type DeleteDatasourceApiV1DatasourcesDatasourceIdDeleteMutationError =
  HTTPValidationError;

/**
 * @summary Delete Datasource
 */
export const useDeleteDatasourceApiV1DatasourcesDatasourceIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<
      ReturnType<typeof deleteDatasourceApiV1DatasourcesDatasourceIdDelete>
    >,
    TError,
    { datasourceId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<
    ReturnType<typeof deleteDatasourceApiV1DatasourcesDatasourceIdDelete>
  >,
  TError,
  { datasourceId: string },
  TContext
> => {
  const mutationOptions =
    getDeleteDatasourceApiV1DatasourcesDatasourceIdDeleteMutationOptions(
      options,
    );

  return useMutation(mutationOptions);
};
/**
 * Test connectivity for an existing data source.
 * @summary Test Datasource Connection
 */
export const testDatasourceConnectionApiV1DatasourcesDatasourceIdTestPost = (
  datasourceId: string,
) => {
  return customInstance<TestConnectionResponse>({
    url: `/api/v1/datasources/${datasourceId}/test`,
    method: "POST",
  });
};

export const getTestDatasourceConnectionApiV1DatasourcesDatasourceIdTestPostMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof testDatasourceConnectionApiV1DatasourcesDatasourceIdTestPost
        >
      >,
      TError,
      { datasourceId: string },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<
        typeof testDatasourceConnectionApiV1DatasourcesDatasourceIdTestPost
      >
    >,
    TError,
    { datasourceId: string },
    TContext
  > => {
    const { mutation: mutationOptions } = options ?? {};

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<
          typeof testDatasourceConnectionApiV1DatasourcesDatasourceIdTestPost
        >
      >,
      { datasourceId: string }
    > = (props) => {
      const { datasourceId } = props ?? {};

      return testDatasourceConnectionApiV1DatasourcesDatasourceIdTestPost(
        datasourceId,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type TestDatasourceConnectionApiV1DatasourcesDatasourceIdTestPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof testDatasourceConnectionApiV1DatasourcesDatasourceIdTestPost
      >
    >
  >;

export type TestDatasourceConnectionApiV1DatasourcesDatasourceIdTestPostMutationError =
  HTTPValidationError;

/**
 * @summary Test Datasource Connection
 */
export const useTestDatasourceConnectionApiV1DatasourcesDatasourceIdTestPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<
      ReturnType<
        typeof testDatasourceConnectionApiV1DatasourcesDatasourceIdTestPost
      >
    >,
    TError,
    { datasourceId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<
    ReturnType<
      typeof testDatasourceConnectionApiV1DatasourcesDatasourceIdTestPost
    >
  >,
  TError,
  { datasourceId: string },
  TContext
> => {
  const mutationOptions =
    getTestDatasourceConnectionApiV1DatasourcesDatasourceIdTestPostMutationOptions(
      options,
    );

  return useMutation(mutationOptions);
};
/**
 * Get schema from a data source.

Returns unified schema with catalogs, schemas, and tables.
 * @summary Get Datasource Schema
 */
export const getDatasourceSchemaApiV1DatasourcesDatasourceIdSchemaGet = (
  datasourceId: string,
  params?: GetDatasourceSchemaApiV1DatasourcesDatasourceIdSchemaGetParams,
  signal?: AbortSignal,
) => {
  return customInstance<SchemaResponseModel>({
    url: `/api/v1/datasources/${datasourceId}/schema`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetDatasourceSchemaApiV1DatasourcesDatasourceIdSchemaGetQueryKey =
  (
    datasourceId: string,
    params?: GetDatasourceSchemaApiV1DatasourcesDatasourceIdSchemaGetParams,
  ) => {
    return [
      `/api/v1/datasources/${datasourceId}/schema`,
      ...(params ? [params] : []),
    ] as const;
  };

export const getGetDatasourceSchemaApiV1DatasourcesDatasourceIdSchemaGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<
        typeof getDatasourceSchemaApiV1DatasourcesDatasourceIdSchemaGet
      >
    >,
    TError = HTTPValidationError,
  >(
    datasourceId: string,
    params?: GetDatasourceSchemaApiV1DatasourcesDatasourceIdSchemaGetParams,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof getDatasourceSchemaApiV1DatasourcesDatasourceIdSchemaGet
            >
          >,
          TError,
          TData
        >
      >;
    },
  ) => {
    const { query: queryOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getGetDatasourceSchemaApiV1DatasourcesDatasourceIdSchemaGetQueryKey(
        datasourceId,
        params,
      );

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<
          typeof getDatasourceSchemaApiV1DatasourcesDatasourceIdSchemaGet
        >
      >
    > = ({ signal }) =>
      getDatasourceSchemaApiV1DatasourcesDatasourceIdSchemaGet(
        datasourceId,
        params,
        signal,
      );

    return {
      queryKey,
      queryFn,
      enabled: !!datasourceId,
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<
          typeof getDatasourceSchemaApiV1DatasourcesDatasourceIdSchemaGet
        >
      >,
      TError,
      TData
    > & { queryKey: QueryKey };
  };

export type GetDatasourceSchemaApiV1DatasourcesDatasourceIdSchemaGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof getDatasourceSchemaApiV1DatasourcesDatasourceIdSchemaGet
      >
    >
  >;
export type GetDatasourceSchemaApiV1DatasourcesDatasourceIdSchemaGetQueryError =
  HTTPValidationError;

/**
 * @summary Get Datasource Schema
 */
export const useGetDatasourceSchemaApiV1DatasourcesDatasourceIdSchemaGet = <
  TData = Awaited<
    ReturnType<typeof getDatasourceSchemaApiV1DatasourcesDatasourceIdSchemaGet>
  >,
  TError = HTTPValidationError,
>(
  datasourceId: string,
  params?: GetDatasourceSchemaApiV1DatasourcesDatasourceIdSchemaGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getDatasourceSchemaApiV1DatasourcesDatasourceIdSchemaGet
          >
        >,
        TError,
        TData
      >
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions =
    getGetDatasourceSchemaApiV1DatasourcesDatasourceIdSchemaGetQueryOptions(
      datasourceId,
      params,
      options,
    );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Execute a query against a data source.

Only works for sources that support SQL or similar query languages.
 * @summary Execute Query
 */
export const executeQueryApiV1DatasourcesDatasourceIdQueryPost = (
  datasourceId: string,
  queryRequest: QueryRequest,
) => {
  return customInstance<QueryResponse>({
    url: `/api/v1/datasources/${datasourceId}/query`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryRequest,
  });
};

export const getExecuteQueryApiV1DatasourcesDatasourceIdQueryPostMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof executeQueryApiV1DatasourcesDatasourceIdQueryPost>
      >,
      TError,
      { datasourceId: string; data: QueryRequest },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof executeQueryApiV1DatasourcesDatasourceIdQueryPost>
    >,
    TError,
    { datasourceId: string; data: QueryRequest },
    TContext
  > => {
    const { mutation: mutationOptions } = options ?? {};

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof executeQueryApiV1DatasourcesDatasourceIdQueryPost>
      >,
      { datasourceId: string; data: QueryRequest }
    > = (props) => {
      const { datasourceId, data } = props ?? {};

      return executeQueryApiV1DatasourcesDatasourceIdQueryPost(
        datasourceId,
        data,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type ExecuteQueryApiV1DatasourcesDatasourceIdQueryPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof executeQueryApiV1DatasourcesDatasourceIdQueryPost>
    >
  >;
export type ExecuteQueryApiV1DatasourcesDatasourceIdQueryPostMutationBody =
  QueryRequest;
export type ExecuteQueryApiV1DatasourcesDatasourceIdQueryPostMutationError =
  HTTPValidationError;

/**
 * @summary Execute Query
 */
export const useExecuteQueryApiV1DatasourcesDatasourceIdQueryPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<
      ReturnType<typeof executeQueryApiV1DatasourcesDatasourceIdQueryPost>
    >,
    TError,
    { datasourceId: string; data: QueryRequest },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof executeQueryApiV1DatasourcesDatasourceIdQueryPost>>,
  TError,
  { datasourceId: string; data: QueryRequest },
  TContext
> => {
  const mutationOptions =
    getExecuteQueryApiV1DatasourcesDatasourceIdQueryPostMutationOptions(
      options,
    );

  return useMutation(mutationOptions);
};
/**
 * Get statistics for columns in a table.

Only works for sources that support column statistics.
 * @summary Get Column Stats
 */
export const getColumnStatsApiV1DatasourcesDatasourceIdStatsPost = (
  datasourceId: string,
  statsRequest: StatsRequest,
) => {
  return customInstance<StatsResponse>({
    url: `/api/v1/datasources/${datasourceId}/stats`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: statsRequest,
  });
};

export const getGetColumnStatsApiV1DatasourcesDatasourceIdStatsPostMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof getColumnStatsApiV1DatasourcesDatasourceIdStatsPost>
      >,
      TError,
      { datasourceId: string; data: StatsRequest },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof getColumnStatsApiV1DatasourcesDatasourceIdStatsPost>
    >,
    TError,
    { datasourceId: string; data: StatsRequest },
    TContext
  > => {
    const { mutation: mutationOptions } = options ?? {};

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof getColumnStatsApiV1DatasourcesDatasourceIdStatsPost>
      >,
      { datasourceId: string; data: StatsRequest }
    > = (props) => {
      const { datasourceId, data } = props ?? {};

      return getColumnStatsApiV1DatasourcesDatasourceIdStatsPost(
        datasourceId,
        data,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type GetColumnStatsApiV1DatasourcesDatasourceIdStatsPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof getColumnStatsApiV1DatasourcesDatasourceIdStatsPost>
    >
  >;
export type GetColumnStatsApiV1DatasourcesDatasourceIdStatsPostMutationBody =
  StatsRequest;
export type GetColumnStatsApiV1DatasourcesDatasourceIdStatsPostMutationError =
  HTTPValidationError;

/**
 * @summary Get Column Stats
 */
export const useGetColumnStatsApiV1DatasourcesDatasourceIdStatsPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<
      ReturnType<typeof getColumnStatsApiV1DatasourcesDatasourceIdStatsPost>
    >,
    TError,
    { datasourceId: string; data: StatsRequest },
    TContext
  >;
}): UseMutationResult<
  Awaited<
    ReturnType<typeof getColumnStatsApiV1DatasourcesDatasourceIdStatsPost>
  >,
  TError,
  { datasourceId: string; data: StatsRequest },
  TContext
> => {
  const mutationOptions =
    getGetColumnStatsApiV1DatasourcesDatasourceIdStatsPostMutationOptions(
      options,
    );

  return useMutation(mutationOptions);
};
/**
 * Sync schema and register/update datasets.

Discovers all tables from the data source and upserts them
into the datasets table. Soft-deletes datasets that no longer exist.
 * @summary Sync Datasource Schema
 */
export const syncDatasourceSchemaApiV1DatasourcesDatasourceIdSyncPost = (
  datasourceId: string,
) => {
  return customInstance<SyncResponse>({
    url: `/api/v1/datasources/${datasourceId}/sync`,
    method: "POST",
  });
};

export const getSyncDatasourceSchemaApiV1DatasourcesDatasourceIdSyncPostMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof syncDatasourceSchemaApiV1DatasourcesDatasourceIdSyncPost
        >
      >,
      TError,
      { datasourceId: string },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<
        typeof syncDatasourceSchemaApiV1DatasourcesDatasourceIdSyncPost
      >
    >,
    TError,
    { datasourceId: string },
    TContext
  > => {
    const { mutation: mutationOptions } = options ?? {};

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<
          typeof syncDatasourceSchemaApiV1DatasourcesDatasourceIdSyncPost
        >
      >,
      { datasourceId: string }
    > = (props) => {
      const { datasourceId } = props ?? {};

      return syncDatasourceSchemaApiV1DatasourcesDatasourceIdSyncPost(
        datasourceId,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type SyncDatasourceSchemaApiV1DatasourcesDatasourceIdSyncPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof syncDatasourceSchemaApiV1DatasourcesDatasourceIdSyncPost
      >
    >
  >;

export type SyncDatasourceSchemaApiV1DatasourcesDatasourceIdSyncPostMutationError =
  HTTPValidationError;

/**
 * @summary Sync Datasource Schema
 */
export const useSyncDatasourceSchemaApiV1DatasourcesDatasourceIdSyncPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<
      ReturnType<
        typeof syncDatasourceSchemaApiV1DatasourcesDatasourceIdSyncPost
      >
    >,
    TError,
    { datasourceId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<
    ReturnType<typeof syncDatasourceSchemaApiV1DatasourcesDatasourceIdSyncPost>
  >,
  TError,
  { datasourceId: string },
  TContext
> => {
  const mutationOptions =
    getSyncDatasourceSchemaApiV1DatasourcesDatasourceIdSyncPostMutationOptions(
      options,
    );

  return useMutation(mutationOptions);
};
/**
 * List datasets for a datasource.
 * @summary List Datasource Datasets
 */
export const listDatasourceDatasetsApiV1DatasourcesDatasourceIdDatasetsGet = (
  datasourceId: string,
  params?: ListDatasourceDatasetsApiV1DatasourcesDatasourceIdDatasetsGetParams,
  signal?: AbortSignal,
) => {
  return customInstance<DatasourceDatasetsResponse>({
    url: `/api/v1/datasources/${datasourceId}/datasets`,
    method: "GET",
    params,
    signal,
  });
};

export const getListDatasourceDatasetsApiV1DatasourcesDatasourceIdDatasetsGetQueryKey =
  (
    datasourceId: string,
    params?: ListDatasourceDatasetsApiV1DatasourcesDatasourceIdDatasetsGetParams,
  ) => {
    return [
      `/api/v1/datasources/${datasourceId}/datasets`,
      ...(params ? [params] : []),
    ] as const;
  };

export const getListDatasourceDatasetsApiV1DatasourcesDatasourceIdDatasetsGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<
        typeof listDatasourceDatasetsApiV1DatasourcesDatasourceIdDatasetsGet
      >
    >,
    TError = HTTPValidationError,
  >(
    datasourceId: string,
    params?: ListDatasourceDatasetsApiV1DatasourcesDatasourceIdDatasetsGetParams,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof listDatasourceDatasetsApiV1DatasourcesDatasourceIdDatasetsGet
            >
          >,
          TError,
          TData
        >
      >;
    },
  ) => {
    const { query: queryOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getListDatasourceDatasetsApiV1DatasourcesDatasourceIdDatasetsGetQueryKey(
        datasourceId,
        params,
      );

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<
          typeof listDatasourceDatasetsApiV1DatasourcesDatasourceIdDatasetsGet
        >
      >
    > = ({ signal }) =>
      listDatasourceDatasetsApiV1DatasourcesDatasourceIdDatasetsGet(
        datasourceId,
        params,
        signal,
      );

    return {
      queryKey,
      queryFn,
      enabled: !!datasourceId,
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<
          typeof listDatasourceDatasetsApiV1DatasourcesDatasourceIdDatasetsGet
        >
      >,
      TError,
      TData
    > & { queryKey: QueryKey };
  };

export type ListDatasourceDatasetsApiV1DatasourcesDatasourceIdDatasetsGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof listDatasourceDatasetsApiV1DatasourcesDatasourceIdDatasetsGet
      >
    >
  >;
export type ListDatasourceDatasetsApiV1DatasourcesDatasourceIdDatasetsGetQueryError =
  HTTPValidationError;

/**
 * @summary List Datasource Datasets
 */
export const useListDatasourceDatasetsApiV1DatasourcesDatasourceIdDatasetsGet =
  <
    TData = Awaited<
      ReturnType<
        typeof listDatasourceDatasetsApiV1DatasourcesDatasourceIdDatasetsGet
      >
    >,
    TError = HTTPValidationError,
  >(
    datasourceId: string,
    params?: ListDatasourceDatasetsApiV1DatasourcesDatasourceIdDatasetsGetParams,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof listDatasourceDatasetsApiV1DatasourcesDatasourceIdDatasetsGet
            >
          >,
          TError,
          TData
        >
      >;
    },
  ): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const queryOptions =
      getListDatasourceDatasetsApiV1DatasourcesDatasourceIdDatasetsGetQueryOptions(
        datasourceId,
        params,
        options,
      );

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
      queryKey: QueryKey;
    };

    query.queryKey = queryOptions.queryKey;

    return query;
  };

/**
 * List all supported data source types.

Returns the configuration schema for each type, which can be used
to dynamically generate connection forms in the frontend.
 * @summary List Source Types
 */
export const listSourceTypesApiV1V2DatasourcesTypesGet = (
  signal?: AbortSignal,
) => {
  return customInstance<SourceTypesResponse>({
    url: `/api/v1/v2/datasources/types`,
    method: "GET",
    signal,
  });
};

export const getListSourceTypesApiV1V2DatasourcesTypesGetQueryKey = () => {
  return [`/api/v1/v2/datasources/types`] as const;
};

export const getListSourceTypesApiV1V2DatasourcesTypesGetQueryOptions = <
  TData = Awaited<ReturnType<typeof listSourceTypesApiV1V2DatasourcesTypesGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof listSourceTypesApiV1V2DatasourcesTypesGet>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getListSourceTypesApiV1V2DatasourcesTypesGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listSourceTypesApiV1V2DatasourcesTypesGet>>
  > = ({ signal }) => listSourceTypesApiV1V2DatasourcesTypesGet(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listSourceTypesApiV1V2DatasourcesTypesGet>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ListSourceTypesApiV1V2DatasourcesTypesGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof listSourceTypesApiV1V2DatasourcesTypesGet>>
>;
export type ListSourceTypesApiV1V2DatasourcesTypesGetQueryError = unknown;

/**
 * @summary List Source Types
 */
export const useListSourceTypesApiV1V2DatasourcesTypesGet = <
  TData = Awaited<ReturnType<typeof listSourceTypesApiV1V2DatasourcesTypesGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof listSourceTypesApiV1V2DatasourcesTypesGet>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions =
    getListSourceTypesApiV1V2DatasourcesTypesGetQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Test a connection without saving it.

Use this endpoint to validate connection settings before creating
a data source.
 * @summary Test Connection
 */
export const testConnectionApiV1V2DatasourcesTestPost = (
  testConnectionRequest: TestConnectionRequest,
) => {
  return customInstance<TestConnectionResponse>({
    url: `/api/v1/v2/datasources/test`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: testConnectionRequest,
  });
};

export const getTestConnectionApiV1V2DatasourcesTestPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof testConnectionApiV1V2DatasourcesTestPost>>,
    TError,
    { data: TestConnectionRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof testConnectionApiV1V2DatasourcesTestPost>>,
  TError,
  { data: TestConnectionRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof testConnectionApiV1V2DatasourcesTestPost>>,
    { data: TestConnectionRequest }
  > = (props) => {
    const { data } = props ?? {};

    return testConnectionApiV1V2DatasourcesTestPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type TestConnectionApiV1V2DatasourcesTestPostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof testConnectionApiV1V2DatasourcesTestPost>>
  >;
export type TestConnectionApiV1V2DatasourcesTestPostMutationBody =
  TestConnectionRequest;
export type TestConnectionApiV1V2DatasourcesTestPostMutationError =
  HTTPValidationError;

/**
 * @summary Test Connection
 */
export const useTestConnectionApiV1V2DatasourcesTestPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof testConnectionApiV1V2DatasourcesTestPost>>,
    TError,
    { data: TestConnectionRequest },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof testConnectionApiV1V2DatasourcesTestPost>>,
  TError,
  { data: TestConnectionRequest },
  TContext
> => {
  const mutationOptions =
    getTestConnectionApiV1V2DatasourcesTestPostMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * List all data sources for the current tenant.
 * @summary List Datasources
 */
export const listDatasourcesApiV1V2DatasourcesGet = (signal?: AbortSignal) => {
  return customInstance<DataSourceListResponse>({
    url: `/api/v1/v2/datasources/`,
    method: "GET",
    signal,
  });
};

export const getListDatasourcesApiV1V2DatasourcesGetQueryKey = () => {
  return [`/api/v1/v2/datasources/`] as const;
};

export const getListDatasourcesApiV1V2DatasourcesGetQueryOptions = <
  TData = Awaited<ReturnType<typeof listDatasourcesApiV1V2DatasourcesGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof listDatasourcesApiV1V2DatasourcesGet>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getListDatasourcesApiV1V2DatasourcesGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listDatasourcesApiV1V2DatasourcesGet>>
  > = ({ signal }) => listDatasourcesApiV1V2DatasourcesGet(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listDatasourcesApiV1V2DatasourcesGet>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ListDatasourcesApiV1V2DatasourcesGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof listDatasourcesApiV1V2DatasourcesGet>>
>;
export type ListDatasourcesApiV1V2DatasourcesGetQueryError = unknown;

/**
 * @summary List Datasources
 */
export const useListDatasourcesApiV1V2DatasourcesGet = <
  TData = Awaited<ReturnType<typeof listDatasourcesApiV1V2DatasourcesGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof listDatasourcesApiV1V2DatasourcesGet>>,
      TError,
      TData
    >
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions =
    getListDatasourcesApiV1V2DatasourcesGetQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create a new data source.

Tests the connection before saving. Returns 400 if connection test fails.
 * @summary Create Datasource
 */
export const createDatasourceApiV1V2DatasourcesPost = (
  createDataSourceRequest: CreateDataSourceRequest,
) => {
  return customInstance<DataSourceResponse>({
    url: `/api/v1/v2/datasources/`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: createDataSourceRequest,
  });
};

export const getCreateDatasourceApiV1V2DatasourcesPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createDatasourceApiV1V2DatasourcesPost>>,
    TError,
    { data: CreateDataSourceRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createDatasourceApiV1V2DatasourcesPost>>,
  TError,
  { data: CreateDataSourceRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createDatasourceApiV1V2DatasourcesPost>>,
    { data: CreateDataSourceRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createDatasourceApiV1V2DatasourcesPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateDatasourceApiV1V2DatasourcesPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createDatasourceApiV1V2DatasourcesPost>>
>;
export type CreateDatasourceApiV1V2DatasourcesPostMutationBody =
  CreateDataSourceRequest;
export type CreateDatasourceApiV1V2DatasourcesPostMutationError =
  HTTPValidationError;

/**
 * @summary Create Datasource
 */
export const useCreateDatasourceApiV1V2DatasourcesPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createDatasourceApiV1V2DatasourcesPost>>,
    TError,
    { data: CreateDataSourceRequest },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof createDatasourceApiV1V2DatasourcesPost>>,
  TError,
  { data: CreateDataSourceRequest },
  TContext
> => {
  const mutationOptions =
    getCreateDatasourceApiV1V2DatasourcesPostMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Get a specific data source.
 * @summary Get Datasource
 */
export const getDatasourceApiV1V2DatasourcesDatasourceIdGet = (
  datasourceId: string,
  signal?: AbortSignal,
) => {
  return customInstance<DataSourceResponse>({
    url: `/api/v1/v2/datasources/${datasourceId}`,
    method: "GET",
    signal,
  });
};

export const getGetDatasourceApiV1V2DatasourcesDatasourceIdGetQueryKey = (
  datasourceId: string,
) => {
  return [`/api/v1/v2/datasources/${datasourceId}`] as const;
};

export const getGetDatasourceApiV1V2DatasourcesDatasourceIdGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getDatasourceApiV1V2DatasourcesDatasourceIdGet>
  >,
  TError = HTTPValidationError,
>(
  datasourceId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getDatasourceApiV1V2DatasourcesDatasourceIdGet>
        >,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetDatasourceApiV1V2DatasourcesDatasourceIdGetQueryKey(datasourceId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDatasourceApiV1V2DatasourcesDatasourceIdGet>>
  > = ({ signal }) =>
    getDatasourceApiV1V2DatasourcesDatasourceIdGet(datasourceId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!datasourceId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getDatasourceApiV1V2DatasourcesDatasourceIdGet>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetDatasourceApiV1V2DatasourcesDatasourceIdGetQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof getDatasourceApiV1V2DatasourcesDatasourceIdGet>>
  >;
export type GetDatasourceApiV1V2DatasourcesDatasourceIdGetQueryError =
  HTTPValidationError;

/**
 * @summary Get Datasource
 */
export const useGetDatasourceApiV1V2DatasourcesDatasourceIdGet = <
  TData = Awaited<
    ReturnType<typeof getDatasourceApiV1V2DatasourcesDatasourceIdGet>
  >,
  TError = HTTPValidationError,
>(
  datasourceId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getDatasourceApiV1V2DatasourcesDatasourceIdGet>
        >,
        TError,
        TData
      >
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions =
    getGetDatasourceApiV1V2DatasourcesDatasourceIdGetQueryOptions(
      datasourceId,
      options,
    );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Delete a data source (soft delete).
 * @summary Delete Datasource
 */
export const deleteDatasourceApiV1V2DatasourcesDatasourceIdDelete = (
  datasourceId: string,
) => {
  return customInstance<void>({
    url: `/api/v1/v2/datasources/${datasourceId}`,
    method: "DELETE",
  });
};

export const getDeleteDatasourceApiV1V2DatasourcesDatasourceIdDeleteMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof deleteDatasourceApiV1V2DatasourcesDatasourceIdDelete>
      >,
      TError,
      { datasourceId: string },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof deleteDatasourceApiV1V2DatasourcesDatasourceIdDelete>
    >,
    TError,
    { datasourceId: string },
    TContext
  > => {
    const { mutation: mutationOptions } = options ?? {};

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof deleteDatasourceApiV1V2DatasourcesDatasourceIdDelete>
      >,
      { datasourceId: string }
    > = (props) => {
      const { datasourceId } = props ?? {};

      return deleteDatasourceApiV1V2DatasourcesDatasourceIdDelete(datasourceId);
    };

    return { mutationFn, ...mutationOptions };
  };

export type DeleteDatasourceApiV1V2DatasourcesDatasourceIdDeleteMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof deleteDatasourceApiV1V2DatasourcesDatasourceIdDelete>
    >
  >;

export type DeleteDatasourceApiV1V2DatasourcesDatasourceIdDeleteMutationError =
  HTTPValidationError;

/**
 * @summary Delete Datasource
 */
export const useDeleteDatasourceApiV1V2DatasourcesDatasourceIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<
      ReturnType<typeof deleteDatasourceApiV1V2DatasourcesDatasourceIdDelete>
    >,
    TError,
    { datasourceId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<
    ReturnType<typeof deleteDatasourceApiV1V2DatasourcesDatasourceIdDelete>
  >,
  TError,
  { datasourceId: string },
  TContext
> => {
  const mutationOptions =
    getDeleteDatasourceApiV1V2DatasourcesDatasourceIdDeleteMutationOptions(
      options,
    );

  return useMutation(mutationOptions);
};
/**
 * Test connectivity for an existing data source.
 * @summary Test Datasource Connection
 */
export const testDatasourceConnectionApiV1V2DatasourcesDatasourceIdTestPost = (
  datasourceId: string,
) => {
  return customInstance<TestConnectionResponse>({
    url: `/api/v1/v2/datasources/${datasourceId}/test`,
    method: "POST",
  });
};

export const getTestDatasourceConnectionApiV1V2DatasourcesDatasourceIdTestPostMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof testDatasourceConnectionApiV1V2DatasourcesDatasourceIdTestPost
        >
      >,
      TError,
      { datasourceId: string },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<
        typeof testDatasourceConnectionApiV1V2DatasourcesDatasourceIdTestPost
      >
    >,
    TError,
    { datasourceId: string },
    TContext
  > => {
    const { mutation: mutationOptions } = options ?? {};

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<
          typeof testDatasourceConnectionApiV1V2DatasourcesDatasourceIdTestPost
        >
      >,
      { datasourceId: string }
    > = (props) => {
      const { datasourceId } = props ?? {};

      return testDatasourceConnectionApiV1V2DatasourcesDatasourceIdTestPost(
        datasourceId,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type TestDatasourceConnectionApiV1V2DatasourcesDatasourceIdTestPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof testDatasourceConnectionApiV1V2DatasourcesDatasourceIdTestPost
      >
    >
  >;

export type TestDatasourceConnectionApiV1V2DatasourcesDatasourceIdTestPostMutationError =
  HTTPValidationError;

/**
 * @summary Test Datasource Connection
 */
export const useTestDatasourceConnectionApiV1V2DatasourcesDatasourceIdTestPost =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof testDatasourceConnectionApiV1V2DatasourcesDatasourceIdTestPost
        >
      >,
      TError,
      { datasourceId: string },
      TContext
    >;
  }): UseMutationResult<
    Awaited<
      ReturnType<
        typeof testDatasourceConnectionApiV1V2DatasourcesDatasourceIdTestPost
      >
    >,
    TError,
    { datasourceId: string },
    TContext
  > => {
    const mutationOptions =
      getTestDatasourceConnectionApiV1V2DatasourcesDatasourceIdTestPostMutationOptions(
        options,
      );

    return useMutation(mutationOptions);
  };
/**
 * Get schema from a data source.

Returns unified schema with catalogs, schemas, and tables.
 * @summary Get Datasource Schema
 */
export const getDatasourceSchemaApiV1V2DatasourcesDatasourceIdSchemaGet = (
  datasourceId: string,
  params?: GetDatasourceSchemaApiV1V2DatasourcesDatasourceIdSchemaGetParams,
  signal?: AbortSignal,
) => {
  return customInstance<SchemaResponseModel>({
    url: `/api/v1/v2/datasources/${datasourceId}/schema`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetDatasourceSchemaApiV1V2DatasourcesDatasourceIdSchemaGetQueryKey =
  (
    datasourceId: string,
    params?: GetDatasourceSchemaApiV1V2DatasourcesDatasourceIdSchemaGetParams,
  ) => {
    return [
      `/api/v1/v2/datasources/${datasourceId}/schema`,
      ...(params ? [params] : []),
    ] as const;
  };

export const getGetDatasourceSchemaApiV1V2DatasourcesDatasourceIdSchemaGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<
        typeof getDatasourceSchemaApiV1V2DatasourcesDatasourceIdSchemaGet
      >
    >,
    TError = HTTPValidationError,
  >(
    datasourceId: string,
    params?: GetDatasourceSchemaApiV1V2DatasourcesDatasourceIdSchemaGetParams,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof getDatasourceSchemaApiV1V2DatasourcesDatasourceIdSchemaGet
            >
          >,
          TError,
          TData
        >
      >;
    },
  ) => {
    const { query: queryOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getGetDatasourceSchemaApiV1V2DatasourcesDatasourceIdSchemaGetQueryKey(
        datasourceId,
        params,
      );

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<
          typeof getDatasourceSchemaApiV1V2DatasourcesDatasourceIdSchemaGet
        >
      >
    > = ({ signal }) =>
      getDatasourceSchemaApiV1V2DatasourcesDatasourceIdSchemaGet(
        datasourceId,
        params,
        signal,
      );

    return {
      queryKey,
      queryFn,
      enabled: !!datasourceId,
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<
          typeof getDatasourceSchemaApiV1V2DatasourcesDatasourceIdSchemaGet
        >
      >,
      TError,
      TData
    > & { queryKey: QueryKey };
  };

export type GetDatasourceSchemaApiV1V2DatasourcesDatasourceIdSchemaGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof getDatasourceSchemaApiV1V2DatasourcesDatasourceIdSchemaGet
      >
    >
  >;
export type GetDatasourceSchemaApiV1V2DatasourcesDatasourceIdSchemaGetQueryError =
  HTTPValidationError;

/**
 * @summary Get Datasource Schema
 */
export const useGetDatasourceSchemaApiV1V2DatasourcesDatasourceIdSchemaGet = <
  TData = Awaited<
    ReturnType<
      typeof getDatasourceSchemaApiV1V2DatasourcesDatasourceIdSchemaGet
    >
  >,
  TError = HTTPValidationError,
>(
  datasourceId: string,
  params?: GetDatasourceSchemaApiV1V2DatasourcesDatasourceIdSchemaGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getDatasourceSchemaApiV1V2DatasourcesDatasourceIdSchemaGet
          >
        >,
        TError,
        TData
      >
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions =
    getGetDatasourceSchemaApiV1V2DatasourcesDatasourceIdSchemaGetQueryOptions(
      datasourceId,
      params,
      options,
    );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Execute a query against a data source.

Only works for sources that support SQL or similar query languages.
 * @summary Execute Query
 */
export const executeQueryApiV1V2DatasourcesDatasourceIdQueryPost = (
  datasourceId: string,
  queryRequest: QueryRequest,
) => {
  return customInstance<QueryResponse>({
    url: `/api/v1/v2/datasources/${datasourceId}/query`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryRequest,
  });
};

export const getExecuteQueryApiV1V2DatasourcesDatasourceIdQueryPostMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof executeQueryApiV1V2DatasourcesDatasourceIdQueryPost>
      >,
      TError,
      { datasourceId: string; data: QueryRequest },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof executeQueryApiV1V2DatasourcesDatasourceIdQueryPost>
    >,
    TError,
    { datasourceId: string; data: QueryRequest },
    TContext
  > => {
    const { mutation: mutationOptions } = options ?? {};

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof executeQueryApiV1V2DatasourcesDatasourceIdQueryPost>
      >,
      { datasourceId: string; data: QueryRequest }
    > = (props) => {
      const { datasourceId, data } = props ?? {};

      return executeQueryApiV1V2DatasourcesDatasourceIdQueryPost(
        datasourceId,
        data,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type ExecuteQueryApiV1V2DatasourcesDatasourceIdQueryPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof executeQueryApiV1V2DatasourcesDatasourceIdQueryPost>
    >
  >;
export type ExecuteQueryApiV1V2DatasourcesDatasourceIdQueryPostMutationBody =
  QueryRequest;
export type ExecuteQueryApiV1V2DatasourcesDatasourceIdQueryPostMutationError =
  HTTPValidationError;

/**
 * @summary Execute Query
 */
export const useExecuteQueryApiV1V2DatasourcesDatasourceIdQueryPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<
      ReturnType<typeof executeQueryApiV1V2DatasourcesDatasourceIdQueryPost>
    >,
    TError,
    { datasourceId: string; data: QueryRequest },
    TContext
  >;
}): UseMutationResult<
  Awaited<
    ReturnType<typeof executeQueryApiV1V2DatasourcesDatasourceIdQueryPost>
  >,
  TError,
  { datasourceId: string; data: QueryRequest },
  TContext
> => {
  const mutationOptions =
    getExecuteQueryApiV1V2DatasourcesDatasourceIdQueryPostMutationOptions(
      options,
    );

  return useMutation(mutationOptions);
};
/**
 * Get statistics for columns in a table.

Only works for sources that support column statistics.
 * @summary Get Column Stats
 */
export const getColumnStatsApiV1V2DatasourcesDatasourceIdStatsPost = (
  datasourceId: string,
  statsRequest: StatsRequest,
) => {
  return customInstance<StatsResponse>({
    url: `/api/v1/v2/datasources/${datasourceId}/stats`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: statsRequest,
  });
};

export const getGetColumnStatsApiV1V2DatasourcesDatasourceIdStatsPostMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof getColumnStatsApiV1V2DatasourcesDatasourceIdStatsPost>
      >,
      TError,
      { datasourceId: string; data: StatsRequest },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof getColumnStatsApiV1V2DatasourcesDatasourceIdStatsPost>
    >,
    TError,
    { datasourceId: string; data: StatsRequest },
    TContext
  > => {
    const { mutation: mutationOptions } = options ?? {};

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof getColumnStatsApiV1V2DatasourcesDatasourceIdStatsPost>
      >,
      { datasourceId: string; data: StatsRequest }
    > = (props) => {
      const { datasourceId, data } = props ?? {};

      return getColumnStatsApiV1V2DatasourcesDatasourceIdStatsPost(
        datasourceId,
        data,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type GetColumnStatsApiV1V2DatasourcesDatasourceIdStatsPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof getColumnStatsApiV1V2DatasourcesDatasourceIdStatsPost>
    >
  >;
export type GetColumnStatsApiV1V2DatasourcesDatasourceIdStatsPostMutationBody =
  StatsRequest;
export type GetColumnStatsApiV1V2DatasourcesDatasourceIdStatsPostMutationError =
  HTTPValidationError;

/**
 * @summary Get Column Stats
 */
export const useGetColumnStatsApiV1V2DatasourcesDatasourceIdStatsPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<
      ReturnType<typeof getColumnStatsApiV1V2DatasourcesDatasourceIdStatsPost>
    >,
    TError,
    { datasourceId: string; data: StatsRequest },
    TContext
  >;
}): UseMutationResult<
  Awaited<
    ReturnType<typeof getColumnStatsApiV1V2DatasourcesDatasourceIdStatsPost>
  >,
  TError,
  { datasourceId: string; data: StatsRequest },
  TContext
> => {
  const mutationOptions =
    getGetColumnStatsApiV1V2DatasourcesDatasourceIdStatsPostMutationOptions(
      options,
    );

  return useMutation(mutationOptions);
};
/**
 * Sync schema and register/update datasets.

Discovers all tables from the data source and upserts them
into the datasets table. Soft-deletes datasets that no longer exist.
 * @summary Sync Datasource Schema
 */
export const syncDatasourceSchemaApiV1V2DatasourcesDatasourceIdSyncPost = (
  datasourceId: string,
) => {
  return customInstance<SyncResponse>({
    url: `/api/v1/v2/datasources/${datasourceId}/sync`,
    method: "POST",
  });
};

export const getSyncDatasourceSchemaApiV1V2DatasourcesDatasourceIdSyncPostMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof syncDatasourceSchemaApiV1V2DatasourcesDatasourceIdSyncPost
        >
      >,
      TError,
      { datasourceId: string },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<
        typeof syncDatasourceSchemaApiV1V2DatasourcesDatasourceIdSyncPost
      >
    >,
    TError,
    { datasourceId: string },
    TContext
  > => {
    const { mutation: mutationOptions } = options ?? {};

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<
          typeof syncDatasourceSchemaApiV1V2DatasourcesDatasourceIdSyncPost
        >
      >,
      { datasourceId: string }
    > = (props) => {
      const { datasourceId } = props ?? {};

      return syncDatasourceSchemaApiV1V2DatasourcesDatasourceIdSyncPost(
        datasourceId,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type SyncDatasourceSchemaApiV1V2DatasourcesDatasourceIdSyncPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof syncDatasourceSchemaApiV1V2DatasourcesDatasourceIdSyncPost
      >
    >
  >;

export type SyncDatasourceSchemaApiV1V2DatasourcesDatasourceIdSyncPostMutationError =
  HTTPValidationError;

/**
 * @summary Sync Datasource Schema
 */
export const useSyncDatasourceSchemaApiV1V2DatasourcesDatasourceIdSyncPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<
      ReturnType<
        typeof syncDatasourceSchemaApiV1V2DatasourcesDatasourceIdSyncPost
      >
    >,
    TError,
    { datasourceId: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<
    ReturnType<
      typeof syncDatasourceSchemaApiV1V2DatasourcesDatasourceIdSyncPost
    >
  >,
  TError,
  { datasourceId: string },
  TContext
> => {
  const mutationOptions =
    getSyncDatasourceSchemaApiV1V2DatasourcesDatasourceIdSyncPostMutationOptions(
      options,
    );

  return useMutation(mutationOptions);
};
/**
 * List datasets for a datasource.
 * @summary List Datasource Datasets
 */
export const listDatasourceDatasetsApiV1V2DatasourcesDatasourceIdDatasetsGet = (
  datasourceId: string,
  params?: ListDatasourceDatasetsApiV1V2DatasourcesDatasourceIdDatasetsGetParams,
  signal?: AbortSignal,
) => {
  return customInstance<DatasourceDatasetsResponse>({
    url: `/api/v1/v2/datasources/${datasourceId}/datasets`,
    method: "GET",
    params,
    signal,
  });
};

export const getListDatasourceDatasetsApiV1V2DatasourcesDatasourceIdDatasetsGetQueryKey =
  (
    datasourceId: string,
    params?: ListDatasourceDatasetsApiV1V2DatasourcesDatasourceIdDatasetsGetParams,
  ) => {
    return [
      `/api/v1/v2/datasources/${datasourceId}/datasets`,
      ...(params ? [params] : []),
    ] as const;
  };

export const getListDatasourceDatasetsApiV1V2DatasourcesDatasourceIdDatasetsGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<
        typeof listDatasourceDatasetsApiV1V2DatasourcesDatasourceIdDatasetsGet
      >
    >,
    TError = HTTPValidationError,
  >(
    datasourceId: string,
    params?: ListDatasourceDatasetsApiV1V2DatasourcesDatasourceIdDatasetsGetParams,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof listDatasourceDatasetsApiV1V2DatasourcesDatasourceIdDatasetsGet
            >
          >,
          TError,
          TData
        >
      >;
    },
  ) => {
    const { query: queryOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getListDatasourceDatasetsApiV1V2DatasourcesDatasourceIdDatasetsGetQueryKey(
        datasourceId,
        params,
      );

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<
          typeof listDatasourceDatasetsApiV1V2DatasourcesDatasourceIdDatasetsGet
        >
      >
    > = ({ signal }) =>
      listDatasourceDatasetsApiV1V2DatasourcesDatasourceIdDatasetsGet(
        datasourceId,
        params,
        signal,
      );

    return {
      queryKey,
      queryFn,
      enabled: !!datasourceId,
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<
          typeof listDatasourceDatasetsApiV1V2DatasourcesDatasourceIdDatasetsGet
        >
      >,
      TError,
      TData
    > & { queryKey: QueryKey };
  };

export type ListDatasourceDatasetsApiV1V2DatasourcesDatasourceIdDatasetsGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof listDatasourceDatasetsApiV1V2DatasourcesDatasourceIdDatasetsGet
      >
    >
  >;
export type ListDatasourceDatasetsApiV1V2DatasourcesDatasourceIdDatasetsGetQueryError =
  HTTPValidationError;

/**
 * @summary List Datasource Datasets
 */
export const useListDatasourceDatasetsApiV1V2DatasourcesDatasourceIdDatasetsGet =
  <
    TData = Awaited<
      ReturnType<
        typeof listDatasourceDatasetsApiV1V2DatasourcesDatasourceIdDatasetsGet
      >
    >,
    TError = HTTPValidationError,
  >(
    datasourceId: string,
    params?: ListDatasourceDatasetsApiV1V2DatasourcesDatasourceIdDatasetsGetParams,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof listDatasourceDatasetsApiV1V2DatasourcesDatasourceIdDatasetsGet
            >
          >,
          TError,
          TData
        >
      >;
    },
  ): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
    const queryOptions =
      getListDatasourceDatasetsApiV1V2DatasourcesDatasourceIdDatasetsGetQueryOptions(
        datasourceId,
        params,
        options,
      );

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
      queryKey: QueryKey;
    };

    query.queryKey = queryOptions.queryKey;

    return query;
  };
